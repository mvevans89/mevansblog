---
title: Advent of Code 2021
author: Michelle
date: '2021-12-05'
slug: []
draft: true
categories: []
tags:
  - R
description: ''
output: html
---

This post will follow my solutions to the [2021 Advent of Code](https://adventofcode.com/2021). Each "day" is it's own self-contained chunk of code, so all of the packages, functions, data, etc. needed for that day is found under that sub-title.

```{r}

options(stringsAsFactors = F, scipen = 999)

#load here package for easier data loading
library(here)
```


# Day 1

## Part I

[Here](https://adventofcode.com/2021/day/1) is a link to the full problem. Essentially, we need to find a way to count instances where `x+1 > x`.  A nice way to do this is via a function.

First, we can create some example data to test our function on:

```{r}
test.data <- floor(runif(10,100,200))
test.data
```

Now we write a function to return the count of how many instances of increase over one step there are:

```{r}
count_increase <- function(vec){
  count <- 0
  for(i in 2:length(vec)){
    if(vec[i]>vec[i-1]) count <- count +1
  }
  return(count)
}
```

Does it work?

```{r}
count_increase(test.data)
```

Now we try it on the true data:

```{r}
#load here package for easier data loading
library(here)
input.data <- read.table(here("static", "data", "advent-code", "day01.txt"))

#test our function
count_increase(input.data$V1)
```

## Part II

For the second part, we want to compare moving window statistics to see the difference in depth across groups of three measurements. For more info on moving window statistics, you can look at an [old post of mine on the topic](https://ditheringdata.netlify.app/2020/02/11/rolling-functions-along-columns/).

For extra challenge, we can this without the help of packages like `zoo` or `dplyr` that already have built in functions for this.

We can make a new function that compares the averages across a rolling window, and make that window itself an argument for the function, so we could apply it to a range of window sizes.

```{r}
count_increase_window <- function(window_size, vec){
  count <- 0
  for(i in (window_size+1):length(vec)){
    if(sum(vec[(i-(window_size-1)):i]) > sum(vec[(i-1):(i-window_size)])) count <- count + 1
  }
  return(count)
}
```

Note that we start the for-loop at `window_size+1` so we our first comparison can be with a full window from `1:window_size`

```{r}
count_increase_window(window_size = 3, vec = input.data$V1)
```

# Day 2

[Link to challenge.](https://adventofcode.com/2021/day/2)

## Part I

For this day, we need to interpret both character and integer data, which come together as one string. 

First, we'll make some test data that matches the test online:

```{r}
directions <- c("up","down", "forward")
test.df <- data.frame(dir = directions[c(3,2,3,1,2,3)], 
                      space = c(5,5,8,3,8,2))

test.df
```

We'll create a function that uses this as instructions to track the movement across two directions. We don't actually need to track the movement at each step, but just know where the submarine is at the end of the movement, so we can simply sum the movements, instead of using a for loop.

```{r}
track_move <- function(move_df){
  # rack positions
  x.position <- sum(as.numeric(move_df[move_df[,1]=="forward",2]))
  y.position <- sum(as.numeric(move_df[move_df[,1]=="down",2])) - sum(as.numeric(move_df[move_df[,1]=="up",2]))
  
  #return the product of these
  return(x.position*y.position)
}
```

```{r}
track_move(test.df) #should equal 150
```

Now we will try it on the input data

```{r}
#load data
input.data <- read.table(here("static", "data", "advent-code", "day02.txt"))

track_move(input.data)
```

## Part II

This part is a little more complicated because it probably will be easier to just track each step, since the angle/direction is dependent on what has happened in the steps beforehand.

For this we will use a series of `if` statements to determine whether each step is affecting the movement or aim of the submarine.

```{r}
track_movement2 <- function(move_df){
  #create vectors to track aim, depth, and horizontal position
  aim <- 0
  depth <- 0
  horiz <- 0
  
  #use a for loop to follow each step of movement
  for(i in 1:nrow(move_df)){
    if(move_df[i,1]=="down") {aim <- aim + move_df[i,2]}
    if(move_df[i,1]=="up") {aim <- aim - move_df[i,2]}
    if(move_df[i,1]=="forward"){
      horiz <- horiz + move_df[i,2]
      depth <- depth + (aim * move_df[i,2])
    }
  }
  
  #return the product of depth and horizontal movement
  return(depth*horiz)
  
}
```

How does this work on the test data?

```{r}
track_movement2(test.df) #should be 900
```

And then we can try on the full dataset

```{r}
track_movement2(input.data)
```

